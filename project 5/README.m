Python 实现 SM2 及签名安全性探索
SM2 是中国国家商用密码中的椭圆曲线签名标准，其广泛应用也带来了实现上潜在的不安全因素。
设计
类接口：允许传入可选的user_id以适配gmssl不同版本的接口差异。
参数处理：内部通过两个辅助函数迭代尝试不同参数组合，自动处理是否需要user_id的问题，避免重复的try/except逻辑。
随机数生成：签名时若未指定k，自动生成256位随机数
随机数误用导致的攻击
SM2 的安全性依赖于签名过程中的随机数k。若k泄露、可预测或重复使用，就会破坏签名的不可伪造性。
1. 已知随机数的危害
签名公式为s= k^{-1}(e+dr)mod n。如果攻击者提前知道签名使用的随机数k，则可以直接代入计算私钥d=r^{-1}(ks-e)。
2. 重复随机数攻击
当同一个k被用于两条不同消息的签名(r,s_1)、(r,s_2)时，会出现如下等式：
s_1-s_2=k^{-1}(e_1-e_2)
进而得到k=(s_1-s_2)^{-1}(e_1- e_2)。一旦求出 k，便能使用上式的已知随机数公式求出私钥。同样的推理在另一篇分析中也展示了如何由两个签名直接求解 k 和私钥。
3. 签名边界检查不足
按照算法规范，签名中的r与s必须满足1≤r,s≤n-1。如果验证函数没有检查这一约束，例如允许r或s为0，则可能接受伪造的签名。我们尝试使用(0,0)作为签名提交到验证函数，新版本gmssl正确返回失败，但历史版本或其它语言实现中曾出现缺陷。
实验结论与防护建议
通过上面的分析，可以得出以下结论：
随机数 k 的安全性与私钥同等重要。
签名验证不仅要检查数学关系，更要验证参数范围。
符合规范的随机数生成器、密钥轮换和日志管理是防止此类攻击的必要措施。
总结
本次实验重新整理了SM2的实现，并用数学推导和实际代码演示了几个常见的签名误用场景。在实现SM2或其他椭圆曲线签名算法时，应格外关注随机数生成、参数检查和密钥管理等环节，以确保加密系统的整体安全。

